<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>FRC Team Search</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: Arial, sans-serif; margin: 2em; background: #f7f7f7; color: #333; }

    h1 { margin-bottom: 0.5em; }
    .controls { display: flex; gap: 1em; align-items: flex-end; margin-bottom: 1em; }
    .controls label { display: flex; flex-direction: column; font-size: 0.9em; }
    .controls input, .controls select, .controls button {
      padding: 0.5em; font-size: 1em; margin-top: 0.25em;
    }

    #go { background: #ee4c23; color: white; border: none; border-radius: 4px; cursor: pointer; }
    #go:hover { background: #bd3c1c; }
    details { margin-bottom: 1em; }
    summary { font-weight: bold; cursor: pointer; }
    .inner-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 1em;
      margin-top: 0.5em;
    }

    .checkbox-group { display: flex; flex-direction: column; font-size: 1em;}
    .checkbox-group label { flex-direction: row; align-items: center; margin-bottom: 0.5em; font-size: 1em;}
    .checkbox-group input { margin-right: 0.5em; margin-top: 0; }
    .checkbox-group span { margin-right: 0.5em; margin-bottom: 10px;font-size: 1.2em; }
    #results { margin-top: 1em; }
    .checkbox-group input[type="checkbox"] {
      accent-color: #ee4c23;
    }

    input[type="number"], input[type="text"], select {
      padding: 0.5em;
      font-size: 1em;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #f9f9f9;
      transition: border-color 0.1s, box-shadow 0.1s;
    }
    
    /* Fix for number inputs */
    input[type="number"] {
      width: 80px;
    }

    input[type="number"]:focus, input[type="text"]:focus, select:focus {
      border-color: #ee4c23;
      box-shadow: 0 0 3px rgba(238, 76, 35, 0.5);
      outline: none;
    }    

    table {
      width: 100%; border-collapse: collapse; background: white; border-radius: 4px; overflow: hidden;
      margin-top: 0.5em;
    }
    th, td {
      padding: 0.75em; text-align: left; border-bottom: 1px solid #e0e0e0;
    }
    th {
      background: #ee4c23; color: white; text-transform: uppercase; font-size: 0.85em;
      white-space: nowrap;
    }
    tr:hover td { background-color: rgba(0, 0, 0, 0.1); }
    @media (max-width: 600px) {
      th, td { padding: 0.5em; font-size: 0.9em; }
    }
    .bottom-controls { display: flex; justify-content: flex-end; margin-top: 0.5em; }
    
    /* New styles for the table format */
    .user-alliance { font-weight: bold; }
    .winning-score { font-weight: bold; }
    .win-row { background-color: rgba(0, 200, 0, 0.1); } /* Light green for wins */
    .loss-row { background-color: rgba(255, 0, 0, 0.1); } /* Light red for losses */
    .searched-team { font-weight: bold; }
    
    /* Make rows clickable */
    tbody tr {
      cursor: pointer;
      transition: background-color 0.2s;
    }
    tbody tr:hover {
      /* background-color: rgba(0, 0, 0, 0.0); */
    }
  </style>
</head>
<body>
  <h1>FRC Team Search</h1>

  <!-- Always visible controls -->
  <div class="controls">
    <label>Year
      <input type="number" id="year" min="2008" max="2099">
    </label>
    <label>Team Key
      <input type="text" id="teamKey" placeholder="e.g. 1902 or frc1902">
    </label>
    <label>Sort Order
      <select id="sortDir">
        <option value="desc" selected>Highest → Lowest</option>
        <option value="asc">Lowest → Highest</option>
      </select>
    </label>
    <button id="go">Fetch Matches</button>
  </div>

  <!-- Accordion for advanced filters -->
  <details>
    <summary>Advanced Filters</summary>
    <div class="inner-controls">
      <label>Event Key
        <input type="text" id="eventKey" placeholder="e.g. 2025flor or 2025miket">
      </label>

      <div class="checkbox-group">
        <span>Comp Level</span>
        <label><input type="checkbox" class="compLevel" value="qm" checked> Qualification (qm)</label>
        <label><input type="checkbox" class="compLevel" value="qf" checked> Quarterfinal (qf)</label>
        <label><input type="checkbox" class="compLevel" value="sf" checked> Semifinal (sf)</label>
        <label><input type="checkbox" class="compLevel" value="f" checked> Final (f)</label>
      </div>

      <label>Alliance Color
        <select id="allianceColor">
          <option value="both" selected>Both</option>
          <option value="blue">Blue</option>
          <option value="red">Red</option>
        </select>
      </label>

      <label>Matches against Team
        <input type="text" id="oppTeam" placeholder="e.g. 254 or frc254">
      </label>

      <label>Matches with Team
        <input type="text" id="allyTeam" placeholder="e.g. 180 or frc180">
      </label>

      <label>Max. Foul Points
        <input type="number" id="maxFoulPoints" placeholder="e.g. 5">
      </label>
    </div>
  </details>

  <!-- Results and bottom control -->
  <div id="results"></div>
  <div class="bottom-controls">
    <label># of Matches
      <input type="number" id="numMatches" value="10" min="1" max="100">
    </label>
  </div>

  <script>
    const PROXY_BASE = 'https://tba-proxy.testtbafrc.workers.dev/proxy';
  
    // Caches
    let cachedTeamKey = '';
    let cachedYear = 0;
    let cachedEventKey = '';
    let cachedMatches = [];
    let cachedDetails = {};
  
    // Default year
    document.getElementById('year').value = new Date().getFullYear();
  
    document.getElementById('go').addEventListener('click', async () => {
      // Read & normalize inputs
      const year = +document.getElementById('year').value;
      let teamKey = document.getElementById('teamKey').value.trim();
      let eventKey = document.getElementById('eventKey').value.trim();
      const compLevels = Array.from(document.querySelectorAll('.compLevel'))
                              .filter(c => c.checked)
                              .map(c => c.value);
      const allianceColor = document.getElementById('allianceColor').value;
      let oppTeam = document.getElementById('oppTeam').value.trim();
      let allyTeam = document.getElementById('allyTeam').value.trim();
      const maxFPraw = document.getElementById('maxFoulPoints').value.trim();
      const maxFP = maxFPraw === '' ? null : +maxFPraw;
      const sortDir = document.getElementById('sortDir').value;
      const numMatches = +document.getElementById('numMatches').value;
      const searchedTeam = teamKey.replace('frc', '');
  
      // Validation & normalization
      if (!year || year < 2008) return alert('Enter a valid year ≥ 2008');
      if (/^\d+$/.test(teamKey)) teamKey = 'frc' + teamKey;
      if (!/^frc\d+$/.test(teamKey)) return alert('Enter a valid team key');
  
      const parseNeg = v => v.startsWith('-')
        ? { val: v.slice(1), exclude: true }
        : { val: v, exclude: false };
      let eK = parseNeg(eventKey), oT = parseNeg(oppTeam), aT = parseNeg(allyTeam);
      
      // Fix event key format
      if (eK.val && !eK.val.startsWith(year.toString())) {
        eK.val = year + eK.val;
      }
      
      [oT, aT].forEach(x => {
        if (x.val && /^\d+$/.test(x.val)) x.val = 'frc' + x.val;
      });
  
      const resEl = document.getElementById('results');
      resEl.innerHTML = '<p>Loading…</p>';
  
      try {
        // Decide if we need a fresh match list
        const needNewList = (
          teamKey !== cachedTeamKey ||
          year !== cachedYear ||
          (eK.val && !eK.exclude) !== cachedEventKey
        );
  
        if (needNewList) {
          cachedTeamKey = teamKey;
          cachedYear = year;
          cachedEventKey = eK.val && !eK.exclude ? eK.val : '';
          cachedMatches = [];
          cachedDetails = {};
  
          let url = `${PROXY_BASE}/team/${teamKey}/matches/${year}`;
          if (eK.val && !eK.exclude) url += `/${eK.val}`;
          const mRes = await fetch(url);
          if (!mRes.ok) throw new Error(`Matches error: ${mRes.status}`);
          cachedMatches = await mRes.json();
        }
  
        // Fetch missing details
        const toFetch = cachedMatches
          .map(m => m.key)
          .filter(key => !(key in cachedDetails));
  
        await Promise.all(toFetch.map(async key => {
          const dRes = await fetch(`${PROXY_BASE}/match/${key}`);
          cachedDetails[key] = dRes.ok ? await dRes.json() : null;
        }));
  
        // Build detailed array
        const detailed = cachedMatches
          .map(m => cachedDetails[m.key])
          .filter(d => d && d.score_breakdown);
  
        // Apply filters and build the enriched match data
        let results = detailed.map(m => {
          const isBlue = m.alliances.blue.team_keys.includes(teamKey);
          const userSide = isBlue ? 'blue' : 'red';
          const oppSide = isBlue ? 'red' : 'blue';
          
          return {
            key: m.key,
            round: `${m.comp_level.toUpperCase()} ${m.match_number}`,
            comp_level: m.comp_level,
            userSide: userSide,
            redTeams: m.alliances.red.team_keys.map(t => t.replace('frc', '')),
            blueTeams: m.alliances.blue.team_keys.map(t => t.replace('frc', '')),
            redScore: m.alliances.red.score,
            blueScore: m.alliances.blue.score,
            foulPoints: m.score_breakdown[userSide].foulPoints || 0,
            oppTeams: m.alliances[oppSide].team_keys,
            allyTeams: m.alliances[userSide].team_keys,
            userScore: isBlue ? m.alliances.blue.score : m.alliances.red.score
          };
        })
        .filter(m => {
          if (!eK.val) return true;
          const evt = m.key.split('_')[0];
          return eK.exclude ? evt !== eK.val : evt === eK.val;
        })
        .filter(m => compLevels.includes(m.comp_level))
        .filter(m => allianceColor === 'both' || m.userSide === allianceColor)
        .filter(m => {
          if (!oT.val) return true;
          const has = m.oppTeams.includes(oT.val);
          return oT.exclude ? !has : has;
        })
        .filter(m => {
          if (!aT.val) return true;
          const has = m.allyTeams.includes(aT.val);
          return aT.exclude ? !has : has;
        })
        .filter(m => {
          if (maxFP === null) return true;
          return m.foulPoints <= maxFP;
        })
        // Sort by user's team score instead of max score
        .sort((a,b) => sortDir === 'desc' ? b.userScore - a.userScore : a.userScore - b.userScore)
        .slice(0, numMatches);
  
        // Render
        if (!results.length) {
          resEl.innerHTML = '<p>No matches found.</p>';
          return;
        }
  
        const rows = results.map(m => {
          // Determine which alliance has the searched team
          const userIsRed = m.redTeams.includes(searchedTeam);
          
          // Determine if the user won
          const userWon = (userIsRed && m.redScore > m.blueScore) || 
                          (!userIsRed && m.blueScore > m.redScore);
          const rowClass = userWon ? 'win-row' : (m.redScore === m.blueScore ? '' : 'loss-row');
          
          // Extract regional code from match key
          const eventCode = m.key.split('_')[0];
          const regionalCode = eventCode.substring(4); // Remove year prefix
          
          // Format the match link text
          const matchLinkText = `${regionalCode.toUpperCase()} ${m.round}`;
          
          // Bold only the searched team number in each alliance
          const formattedRedTeams = m.redTeams.map(team => 
            team === searchedTeam ? `<span class="searched-team">${team}</span>` : team
          ).join(' ');
          
          const formattedBlueTeams = m.blueTeams.map(team => 
            team === searchedTeam ? `<span class="searched-team">${team}</span>` : team
          ).join(' ');
          
          // Bold only the user's team score (not the winning score)
          const redScoreClass = userIsRed ? 'searched-team' : '';
          const blueScoreClass = !userIsRed ? 'searched-team' : '';
          
          // Create the match URL for the entire row
          const matchUrl = `https://www.thebluealliance.com/match/${m.key}`;
          
          return `
            <tr class="${rowClass}" onclick="window.open('${matchUrl}', '_blank')">
              <td>${matchLinkText}</td>
              <td>${formattedRedTeams}</td>
              <td>${formattedBlueTeams}</td>
              <td><span class="${redScoreClass}">${m.redScore}</span> - <span class="${blueScoreClass}">${m.blueScore}</span></td>
            </tr>
          `;
        }).join('');
  
        resEl.innerHTML = `
          <table>
            <thead>
              <tr>
                <th>Match</th>
                <th>Red Alliance</th>
                <th>Blue Alliance</th>
                <th>Score</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>`;
      } catch (err) {
        resEl.innerHTML = `<p style="color:red;">${err.message}</p>`;
      }
    });
  </script>
</body>
</html>